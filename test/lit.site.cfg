# -*- Python -*-

# Configuration file for the 'lit' test runner.

import os
import sys
import shutil
from os import path

import lit.util
import lit.formats

# name: The name of this test suite.
config.name = 'B3'

config.test_format = lit.formats.ShTest(execute_external=False)

# suffixes: A list of file extensions to treat as test files. This is overriden
# by individual lit.local.cfg files in the test subdirectories.
config.suffixes = ['.b3']

# excludes: A list of directories to exclude from the testsuite.
config.excludes = []

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(os.path.abspath(__file__))

# test_exec_root: The root path where tests should be run.
config.test_exec_root = config.test_source_root

config.environment['MSBUILDSINGLELOADCONTEXT'] = "1"

PROPAGATE_ENV = [
    'APPDATA',
    'HOME',
    'INCLUDE',
    'LIB',

    # Fixes error on Windows: build cache is required, but could not be located:
    # GOCACHE is not defined and %LocalAppData% is not defined
    'LOCALAPPDATA',

    'NODE_PATH',

    # Fixes NuGet.targets(564,5): error : Value cannot be null. (Parameter 'path1')
    'ProgramFiles',
    'ProgramFiles(x86)',

    # Prevent dotnet from creating a folder called %SystemDrive%
    'SystemDrive',

    'TEMP',
    'TMP',
    'USERPROFILE',
]

for var in PROPAGATE_ENV:
    if var in os.environ:
        config.environment[var] = os.environ[var]

# Prevent this issue on windows: https://github.com/dotnet/sdk/issues/8887
if 'HOMEPATH' in os.environ and 'HOMEDRIVE' in os.environ:
    config.environment['DOTNET_CLI_HOME'] = os.environ['HOMEDRIVE'] + os.environ['HOMEPATH']

# Propagate PYTHON_EXECUTABLE into the environment
config.environment['PYTHON_EXECUTABLE'] = getattr(config, 'python_executable', '')

# Silence dotnet's welcome message
config.environment['DOTNET_NOLOGO'] = "true"

# Check that the object root is known.
if config.test_exec_root is None:
    lit_config.fatal('Could not determine execution root for tests!')

"""
   Function for quoting filepaths
   so that if they contain spaces
   lit's shell interpreter will
   treat the path as a single argument
"""
def quotePath(path):
    if ' ' in path:
        return '"{path}"'.format(path=path)
    else:
        return path

### Add B3 specific substitutions

# Find b3.dll
up = os.path.dirname
repositoryRoot = up(up( os.path.abspath(__file__) ))
lit_config.note('Repository root is {}'.format(repositoryRoot))

binaryDir = os.path.join(repositoryRoot, 'bin')
config.b3BinaryDir = binaryDir
sourceDir = os.path.join(repositoryRoot, 'src')

defaultB3Executable = quotePath(os.path.join(binaryDir, 'b3'))
b3Executable = lit_config.params.get('executable', defaultB3Executable )

config.suffixes.append('.transcript')

b3Args = [
]
    
# Add standard parameters
def addParams(cmd):
    b3Params = lit_config.params.get('b3_params','')
    if len(b3Params) > 0:
        return f'{cmd} {b3Params}'
    else:
        return cmd

# Add run specific parameters
def buildCmd(cmd, args):
    if len(args) > 0:
        argStr = ' /'.join(args)
        return f'{cmd} /{argStr}'
    else:
        return cmd
        
b3 = buildCmd(b3Executable, b3Args)

standardArguments = addParams(' '.join([]))

# Inform user what executable is being used
lit_config.note(f'Using B3 (%b3): {b3}\n')

ver = "0"
if os.name != "nt":
    ver = os.uname().version

config.substitutions.append( ('%repositoryRoot', repositoryRoot) )
config.substitutions.append( ('%b3', b3) )
config.substitutions.append( ('%args', standardArguments) )
config.substitutions.append( ('%os', os.name) )
config.substitutions.append( ('%ver', ver ) )
config.substitutions.append( ('%sed', 'sed -E' ) )
config.substitutions.append( ('%exits-with', "python3 " + os.path.join(repositoryRoot, 'Scripts/test-exit.py') ) )
config.substitutions.append( ('!', "python3 " + os.path.join(repositoryRoot, 'Scripts/test-exit.py') + " -z" ) )

if os.name == "nt":
    config.available_features = [ 'windows' ]
elif "Darwin" in ver:
    config.available_features = [ 'macosx', 'posix' ]
elif "18.04" in ver and "Ubuntu" in ver:
    config.available_features = [ 'ubuntu18', 'ubuntu', 'posix' ]
else:
    config.available_features = [ 'ubuntu', 'posix' ]

# Sanity check: Check solver executable is available
solverRoots = os.pathsep.join(
    (path.dirname(b3Executable), binaryDir, os.environ["PATH"])
)

print(solverRoots)

solverPath = \
    lit.util.which("z3-4.12.1", solverRoots) or \
    lit.util.which("cvc4", solverRoots)

if not solverPath:
    lit_config.fatal('Could not find solver')
config.substitutions.append( ('%z3', solverPath ) )

# Add diff tool substitution
commonDiffFlags=' --unified=3 --strip-trailing-cr'
diffExecutable = None
if os.name == 'posix' or os.name == 'nt':
    pydiff = quotePath( os.path.join(config.test_source_root, 'pydiff.py') )
    diffExecutable = sys.executable + ' ' + pydiff + commonDiffFlags
else:
    lit_config.fatal('Unsupported platform')
lit_config.note("Using diff tool '{}'".format(diffExecutable))

config.substitutions.append( ('%diff', diffExecutable ))

# Detect the OutputCheck tool
outputCheckPath = lit.util.which('OutputCheck')
if outputCheckPath == None:
    lit_config.fatal('The OutputCheck tool is not in your PATH. Please install it.')

config.substitutions.append( ('%OutputCheck', outputCheckPath + ' --dump-file-to-check  --comment=//') )

config.substitutions.append( ('%{dirsep}', os.sep) )
