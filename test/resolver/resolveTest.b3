// RUN: %b3 resolve --rprint "%s" > "%t"
// RUN: %diff "%s.expect" "%t"

// here is a comment

procedure Test(x:int)   procedure // another comment alright
Mote() {var x: string
val y: int := 200

  MyLabel: {
exit MyLabel
  }
              return return
  { return }
  {}{  }

  myLabel: { check true }

  check true
  assume true
  assert true
  probe 96

  forall x: int {
    check true
    val y: bool := false
    assume y
  }

  if false {
    return return
  }

  hello: {
    var something: bool
    if something { } else {
      exit hello
    }
  }

  four: {
    yes: {
      var AaA: bool
      var BbB: bool
      var CcC: bool
      if AaA {}
      else if BbB {}
      else if CcC {}

      if
        case true { return }
        case true { exit four }

      var s600: bool
      var s601: bool
      var s602: bool
      var s603: bool
      if s600 { exit yes }
      else if case s601 { } case s602 { } case s603 { check true }
    }
  }

  var a: int
  var x: int
  var y: int
  x := 800
  y := 801

  loop { a := 1 }
  loop
    invariant true { }
  asap :loop
    invariant true
    invariant true
    invariant { check true assume true if true { assume true }}
    invariant true
  { exit asap }

  M0()
  M1(1000)
  M2(out x, 1000)
  M3(out x, 1000, inout y)
  var b: int
  var c: int
  var z: int
  M4(1000, out a, out b, out c)
  M5(1000, 2000, inout x, inout y, inout z)
  var m: int
  var n: int
  M6(1000, 2000, inout m, inout n, out x, out z)
}

type string type
MyClass

  procedure Egon( testb  :bool, inout testi :  int,abc: bool,out xyz: string)

procedure   MyProc   (     )
  requires true
  requires true
  requires true
  requires { check true assume true if false { assume false }}
  ensures { check true assume true if false { assume false }}
  ensures true
{ }

procedure M0()
procedure M1(g: int)
procedure M2(out g: int, h: int)
procedure M3(out g: int, h: int, inout i: int)
procedure M4(g: int, out h: int, out i: int, out j: int)
procedure M5(g: int, h: int, inout i: int, inout j: int, inout k: int)
procedure M6(g: int, h: int, inout i: int, inout j: int, out k: int, out l: int)

function F(a: int, injective b: bool): bool

function G(): int
when true {
  15
}

function H(injective str: string, a: int): string
  when str == str
  when a < 10
{
  str
}

function NicelyIndented(x: int, y: int, b: bool, c: MyClass): int
{
  if x == 12 then
    20
  else if x == 13 then
    val u: int := 2 * y
    val v: int := 3 * u + x
    if u + v <= v + u then
      300
    else
      -1 + G()
  else
    4000
}

function AnotherNicelyIndented(x: int, y: int): bool
{
  x < y
  &&
  x <= y
  &&
  x != y
  &&
  (x > y
    &&
      x >= y)
  &&
  x <= y
  &&
    val u: int := 19
    val v: int := 21
    if u + v <= v + u then
      300 < 400
    else
      -1 + G() != 75
}

// -------

type Abc

procedure TestTypeUse(y: Abc) {
  var x: Abc
  x := y
  check x == y

  var k: int := 12
  check Inc(k) == Inc(12)
}

function Inc(x: int): int

// -------

type MyString

function Stringy(s: MyString): bool

procedure UseQuantifier(t: MyString, u: MyString) {
  assume forall s: MyString pattern Stringy(s) :: s != t ==> Stringy(s)
  if t != u {
    check Stringy(u)
  }
}

// ------- optional types

procedure OptionalType(w: int, x: int, out r: int) {
  var y := x // Look, Ma! No type!
  var z :=
    5 +
    val u := if w < x then 2 else y
    u + u
  r := y + z
}

// ------- axioms and taggers

axiom true ==> 5 < 7

tagger MyTag for MyClass

function NotStringy(s: MyString): bool

axiom forall s: MyString pattern Stringy(s) pattern NotStringy(s) :: Stringy(s) || NotStringy(s)
