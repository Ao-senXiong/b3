// Resolved B3 program

type string

type MyClass

type Abc

type MyString

type Color

type List

tagger MyTag for MyClass

tagger ColorTag for Color

tagger ListTag for List

function F(a: int, injective b: bool): bool

function G(): int
  when true
{
  15
}

function H(injective str: string, a: int): string
  when str == str
  when a < 10
{
  str
}

function NicelyIndented(x: int, y: int, b: bool, c: MyClass): int
{
  if x == 12 then
    20
  else if x == 13 then
    val u: int := 2 * y
    val v: int := 3 * u + x
    if u + v <= v + u then
      300
    else
      -1 + G()
  else
    4000
}

function AnotherNicelyIndented(x: int, y: int): bool
{
  x < y && x <= y && x != y && y < x && y <= x && x <= y &&
  val u: int := 19
  val v: int := 21
  if u + v <= v + u then
    300 < 400
  else
    -1 + G() != 75
}

function Inc(x: int): int

function Stringy(s: MyString): bool

function NotStringy(s: MyString): bool

function Red(): Color tag ColorTag

function Green(): Color tag ColorTag

function Gray(injective n: int): Color tag ColorTag

function Nil(): List tag ListTag

function Cons(injective head: int, injective tail: List): List tag ListTag

axiom
  true ==>
  5 < 7

axiom
  forall s: MyString
    pattern Stringy(s)
    pattern NotStringy(s)
  ::
    Stringy(s) ||
    NotStringy(s)

procedure Test(x: int)

procedure Mote()
{
  return: {
    var x: string
    val y: int := 200
    MyLabel: {
      exit MyLabel
    }
    exit return
    exit return
    {
      exit return
    }
    {
    }
    {
    }
    myLabel: {
      check true
    }
    check true
    assume true
    assert true
    probe 96
    forall x: int {
      check true
      val y: bool := false
      assume y
    }
    choose {
      assume false
      exit return
      exit return
    } or {
      assume !false
    }
    hello: {
      var something: bool
      choose {
        assume something
      } or {
        assume !something
        exit hello
      }
    }
    four: {
      yes: {
        var AaA: bool
        var BbB: bool
        var CcC: bool
        choose {
          assume AaA
        } or {
          assume !AaA
          choose {
            assume BbB
          } or {
            assume !BbB
            choose {
              assume CcC
            } or {
              assume !CcC
            }
          }
        }
        choose {
          assume true
          exit return
        } or {
          assume true
          exit four
        }
        var s600: bool
        var s601: bool
        var s602: bool
        var s603: bool
        choose {
          assume s600
          exit yes
        } or {
          assume !s600
          choose {
            assume s601
          } or {
            assume s602
          } or {
            assume s603
            check true
          }
        }
      }
    }
    var a: int
    var x: int
    var y: int
    x := 800
    y := 801
    loop: loop {
      a := 1
    }
    loop: loop
      invariant true
    {
    }
    asap: {
      loop: loop
        invariant true
        invariant true
        invariant {
          check true
          assume true
          choose {
            assume true
            assume true
          } or {
            assume !true
          }
        }
        invariant true
      {
        exit asap
      }
    }
    M0()
    M1(1000)
    M2(out x, 1000)
    M3(out x, 1000, inout y)
    var b: int
    var c: int
    var z: int
    M4(1000, out a, out b, out c)
    M5(1000, 2000, inout x, inout y, inout z)
    var m: int
    var n: int
    M6(1000, 2000, inout m, inout n, out x, out z)
  }
}

procedure Egon(testb: bool, inout testi: int, abc: bool, out xyz: string)

procedure MyProc()
  requires true
  requires true
  requires true
  requires {
    check true
    assume true
    choose {
      assume false
      assume false
    } or {
      assume !false
    }
  }
  ensures {
    check true
    assume true
    choose {
      assume false
      assume false
    } or {
      assume !false
    }
  }
  ensures true
{
  return: {
  }
}

procedure M0()

procedure M1(g: int)

procedure M2(out g: int, h: int)

procedure M3(out g: int, h: int, inout i: int)

procedure M4(g: int, out h: int, out i: int, out j: int)

procedure M5(g: int, h: int, inout i: int, inout j: int, inout k: int)

procedure M6(g: int, h: int, inout i: int, inout j: int, out k: int, out l: int)

procedure TestTypeUse(y: Abc)
{
  return: {
    var x: Abc
    x := y
    check x == y
    var k: int := 12
    check Inc(k) == Inc(12)
  }
}

procedure UseQuantifier(t: MyString, u: MyString)
{
  return: {
    assume forall s: MyString pattern Stringy(s) :: s != t ==> Stringy(s)
    choose {
      assume t != u
      check Stringy(u)
    } or {
      assume !t != u
    }
  }
}

procedure OptionalType(w: int, x: int, out r: int)
{
  return: {
    var y: int := x
    var z: int := 5 + val u: int := if w < x then 2 else y u + u
    r := y + z
  }
}
